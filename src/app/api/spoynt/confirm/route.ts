import { NextRequest, NextResponse } from "next/server";
import { requireAuth } from "@/backend/middlewares/auth.middleware";
import { userController } from "@/backend/controllers/user.controller";
import { spoyntPaymentService } from "@/backend/services/spoyntPayment.service";

function assertEnv(name: string): string {
    const v = process.env[name];
    if (!v) throw new Error(`Missing env: ${name}`);
    return v;
}

function basicAuthHeader(username: string, password: string) {
    const token = Buffer.from(`${username}:${password}`).toString("base64");
    return `Basic ${token}`;
}

function isForceSuccessEnabled() {
    return process.env.SPOYNT_FORCE_SUCCESS === "true" && process.env.NODE_ENV !== "production";
}

export async function GET(req: NextRequest) {
    try {
        const payload = await requireAuth(req);
        const cpi = new URL(req.url).searchParams.get("cpi");

        if (!cpi) return NextResponse.json({ message: "Missing cpi" }, { status: 400 });

        if (isForceSuccessEnabled()) {
            const tokensFromQuery = Number(new URL(req.url).searchParams.get("tokens"));
            const tokens = Number.isFinite(tokensFromQuery) && tokensFromQuery > 0 ? tokensFromQuery : null;

            const creditLock = await spoyntPaymentService.tryBeginCredit(cpi);
            if (creditLock) {
                try {
                    const creditTokens = tokens ?? (creditLock.tokens || 0);
                    if (creditTokens <= 0) {
                        return NextResponse.json({ status: "failed", message: "Missing tokens in sandbox" });
                    }

                    const user = await userController.buyTokens(payload.sub, Math.floor(creditTokens));
                    await spoyntPaymentService.markCredited(cpi);

                    return NextResponse.json({ status: "credited", tokens: Math.floor(creditTokens), user, forced: true });
                } catch (err) {
                    await spoyntPaymentService.releaseCreditLock(cpi);
                    throw err;
                }
            }

            const existing = await spoyntPaymentService.getByCpi(cpi);
            if (existing?.credited) {
                return NextResponse.json({ status: "credited", tokens: existing.tokens, forced: true });
            }

            return NextResponse.json({ status: "processing" });
        }

        const SPOYNT_BASE_URL = assertEnv("SPOYNT_BASE_URL");
        const SPOYNT_ACCOUNT_ID = assertEnv("SPOYNT_ACCOUNT_ID");
        const SPOYNT_API_KEY = assertEnv("SPOYNT_API_KEY");

        const url = `${SPOYNT_BASE_URL}/payment-invoices/${encodeURIComponent(cpi)}`;

        const r = await fetch(url, {
            method: "GET",
            headers: {
                Accept: "application/json",
                Authorization: basicAuthHeader(SPOYNT_ACCOUNT_ID, SPOYNT_API_KEY),
            },
            cache: "no-store",
        });

        const text = await r.text();
        if (!r.ok) {
            console.log("[Spoynt] confirm fetch error", { status: r.status, body: text });
            return NextResponse.json({ message: "Spoynt fetch failed", details: text }, { status: 502 });
        }

        const json = JSON.parse(text);
        console.log("[Spoynt] confirm fetch response", json);
        const attrs = json?.data?.attributes;

        const status = attrs?.status;
        const resolution = attrs?.resolution;
        const metadata = attrs?.metadata || {};

        const userId = metadata.user_id;
        const tokens = Number(metadata.tokens);

        if (!userId || !Number.isFinite(tokens) || tokens <= 0) {
            return NextResponse.json({ message: "Invoice metadata missing" }, { status: 400 });
        }

        if (userId !== payload.sub) {
            return NextResponse.json({ message: "Not your payment" }, { status: 403 });
        }

        await spoyntPaymentService.markStatusByCpi({
            cpi,
            status,
            resolution,
            metadata,
            confirmed: true,
            userId,
            tokens,
            amount: Number(attrs?.amount),
            currency: attrs?.currency,
            referenceId: attrs?.reference_id,
        });

        if (status === "processed" && resolution === "ok") {
            const creditLock = await spoyntPaymentService.tryBeginCredit(cpi);
            if (!creditLock) {
                const existing = await spoyntPaymentService.getByCpi(cpi);
                if (existing?.credited) {
                    return NextResponse.json({ status: "credited", tokens: Math.floor(tokens) });
                }
                return NextResponse.json({ status: "processing" });
            }

            try {
                const user = await userController.buyTokens(payload.sub, Math.floor(tokens));
                await spoyntPaymentService.markCredited(cpi);
                return NextResponse.json({ status: "credited", tokens: Math.floor(tokens), user });
            } catch (err) {
                await spoyntPaymentService.releaseCreditLock(cpi);
                throw err;
            }
        }

        if (status === "pending" || status === "created") {
            return NextResponse.json({ status: "pending" });
        }

        return NextResponse.json({ status: "failed", message: "Payment not confirmed", spoynt: { status, resolution } });
    } catch (err: any) {
        return NextResponse.json({ message: err?.message || "Unknown error" }, { status: 400 });
    }
}